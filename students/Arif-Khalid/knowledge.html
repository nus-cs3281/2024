<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="generator" content="MarkBind 5.4.0">
    <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="stylesheet" href="/2024/markbind/css/bootstrap.min.css"> <link rel="stylesheet" href="/2024/markbind/fontawesome/css/all.min.css"> <link rel="stylesheet" href="/2024/markbind/glyphicons/css/bootstrap-glyphicons.min.css"><link rel="stylesheet" href="/2024/markbind/css/codeblock-light.min.css"><link rel="stylesheet" href="/2024/markbind/css/markbind.min.css"><script src="/2024/markbind/js/polyfill.min.js"></script>
    <script src="/2024/markbind/js/vue.min.js"></script>
    <script src="/2024/markbind/js/markbind.min.js"></script>
    <script src="knowledge.page-vue-render.js"></script><link rel="stylesheet" href="/2024/plugins/markbind-plugin-anchors/markbind-plugin-anchors.css"><link rel="stylesheet" href="/2024/plugins/markbind-plugin-tree/markbind-plugin-tree.css">
    
  <link rel="stylesheet" href="/2024/stylesheets/main.css">
<link rel="icon" href="/2024/favicon.ico"></head>
<script>
  const baseUrl = '/2024'
</script>
<body >
<div id="app" data-server-rendered="true"><header fixed=""><div placement="top" data-v-7c0fd418><nav class="navbar navbar-expand-md d-print-none navbar-dark bg-primary" data-v-7c0fd418><div class="container-fluid" data-v-7c0fd418><div class="navbar-left" data-v-7c0fd418><a href="/2024/index.html" title="Home" class="navbar-brand" data-v-7c0fd418>CS3281&amp;2-2024/Students</a></div> <div class="navbar-default" data-v-7c0fd418><ul class="navbar-nav me-auto mt-2 mt-lg-0" data-v-7c0fd418> <li class="nav-link dropdown" data-v-ccda25c0><a role="button" data-bs-toggle="dropdown" class="dropdown-toggle nav-link" data-v-ccda25c0>CS3281</a> <ul class="dropdown-menu" data-v-ccda25c0> <li data-v-ccda25c0><a href="/2024/index.html" class="dropdown-item" data-v-ccda25c0>Students</a></li> <li data-v-ccda25c0><a href="/2024/students/knowledge.html" class="dropdown-item" data-v-ccda25c0>Knowledge</a></li> <li data-v-ccda25c0><a href="https://nus-cs3281.github.io/2024-dashboard/?search=&amp;sort=groupTitle&amp;sortWithin=title&amp;timeframe=commit&amp;mergegroup=&amp;groupSelect=groupByAuthors&amp;breakdown=false" class="dropdown-item" data-v-ccda25c0>Code Dashboard</a></li></ul></li> <li class="nav-link dropdown" data-v-ccda25c0><a role="button" data-bs-toggle="dropdown" class="dropdown-toggle nav-link" data-v-ccda25c0>CS3282</a> <ul class="dropdown-menu" data-v-ccda25c0> <li data-v-ccda25c0><a href="/2024/cs3282-index.html" class="dropdown-item" data-v-ccda25c0>Students</a></li> <li data-v-ccda25c0><a href="/2024/students/talksSchedule.html" class="dropdown-item" data-v-ccda25c0>Lightning Talks</a></li></ul></li> <li data-v-7c0fd418><a href="/2024/instructions.html" class="nav-link" data-v-7c0fd418>Instructions</a></li> <li data-v-7c0fd418><a href="https://nus-cs3281.github.io/website/" class="nav-link" data-v-7c0fd418>CS3281&amp;2 Website <span data-v-7c0fd418><span aria-hidden="true" class="glyphicon glyphicon-share-alt" data-v-7c0fd418></span></span></a></li></ul></div> <ul class="navbar-nav navbar-right" data-v-7c0fd418><li data-v-7c0fd418><a href="https://github.com/nus-cs3281/2024" class="nav-link" data-v-7c0fd418><span data-v-7c0fd418><span aria-hidden="true" class="fab fa-github" data-v-7c0fd418></span></span></a></li></ul></div></nav> <div class="lower-navbar-container" style="display:none;" data-v-7c0fd418><!----> <!----></div></div></header> <div id="flex-body"><div id="content-wrapper" class="fixed-header-padding"><h3 id="angular">Angular<a href="#angular" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p>In order to work on CATcher and WATcher, I had to learn how to use Angular. With a background in react, it was a difficult transition due to the added checks and strict nature of Angular.<br>
Below are a few of my learning points:</p> <ul><li>Components:
<ul><li>Each component consists of 4 different files, each of them critical to know. Logic can be contained in either typescript of html component files and you initialise other components through the HTML rather than the typescript file</li> <li>Components also have a module file which is where its dependencies are stated, i.e., the other components, services, modules it depends on</li></ul></li> <li>Services:
<ul><li>Each service is like a component but without anything to display. They perform functions that could be contained within components but are extracted out to increase modularity and reusability</li> <li>Like components, services can depend on other services and are often injected into components as dependencies</li></ul></li> <li>Modules:
<ul><li>Modules are containers for a dedicated group of files consisting of components, services or other modules</li> <li>Each module conventionally contains all the code pertaining to a certain feature</li> <li>The root module thus contains all code in the code base, child modules under the root module contain more feature-specific code in a hierarchial structure</li> <li>Modules are critical to understand in order to understand the code base and create new features</li></ul></li> <li>RxJS
<ul><li>While not exactly part of angular, it is important in learning angular as they are often if not always used in tandem</li> <li>RxJS is a library that allows reactive programming, i.e., the ability to subscribe to changes instead of polling for a change</li> <li>This makes it easier to compose asynchronous and cleaner, more optimized code using observer pattern</li> <li>Observers are a very useful tool that allows me to react to changes by subscribing to an event. This contributes to cleaner, more optimised and reusable code.</li> <li>Pipes allow you to consevutively call functions on the prior function's output, similar to function chaining. This allows us to have cleaner and reusable and more understandable code since you don't need to call functions separately and you can create functions out of a chain of other functions easily.</li> <li>Not to be confused with angular pipes which run via the &quot;|&quot; symbol in the html file, allowing you to transform data before it is displayed to the user.</li></ul></li></ul> <p>I learned Angular through various Youtube tutorials, Udemy tutorials, reading the documentation and trying out different things through personal test projects venturing into Angular.</p> <ul><li>Youtube taught me basic fundamentals of Angular.</li> <li>Udemy taught me more in depth and guided me through small personal projects.</li> <li>The documentation gave me deeper understanding and insight into details not covered in tutorials</li></ul> <h3 id="typescript">TypeScript<a href="#typescript" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p>Angular uses TypeScript, so I needed to learn TypeScript. I had only a background in JavaScript while working with React and learning TypeScript had its own difficulties.
Below are a few of my learning points:</p> <ul><li>What and Why TypeScript:
<ul><li>TypeScript acts as a wrapper over JavaScript, compiling into JavaScript code behind the scenes when you build your project</li> <li>The reason people use TypeScript is because of the increased strictness where things have to be statically typed. This reduces the occurences of bugs and makes bugs easier to find when they do occur</li> <li>This makes TypeScript an extremely useful language to pick up and is used widely in industry</li></ul></li> <li>Types:
<ul><li>As in the name, typescript has types and almost everything is required to by statically typed</li> <li>The &quot;any&quot; type bypassed this requirement but is generally regarded as a bad practice as you have made TypeScript into JavaScript</li> <li>You can define your own types and use those types, similar to a typedef in other languages. This is often how objects are passed in TypeScript</li></ul></li></ul> <p>I learned TypeScript through Youtube tutorials</p> <ul><li>Youtube taught me the fundamentals as well as understanding the why and underlying implementation of typescript</li></ul> <h3 id="continuous-integration-continuous-deployment-ci-cd">Continuous Integration/Continuous Deployment (CI/CD)<a href="#continuous-integration-continuous-deployment-ci-cd" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p>As an area I have litte experience in, I wanted to dive into the CI/CD pipeline of CATcher and WATcher, gain an understanding of how it works and contribute to make it better.
Below are a few of my learning points:</p> <ul><li>Automated testing
<ul><li>With large projects like CATcher and WATcher, there are many areas that can and unavoidably will go wrong with many contributors editing different parts of the code base</li> <li>Manual testing is very time consuming when there are so many features to test, any one of which could have been broken by any changes to the code</li> <li>Human error might also cause us to miss certain bugs as we simply did not test for them</li> <li>Automated testing allows for pre-written tests that perform these checks quickly on a headless browser when making any changes, greatly reducing the occurence of uncaught bugs introduced</li> <li>Test case design must be comprehensive in positive and negative cases without testing every specific possible input, instead grouping inputs such as all invalid types given into one test case</li></ul></li> <li>Continuous deployment
<ul><li>With mission-critical projects like CATcher, it is imperative to have automated deployment</li> <li>One reason is to maintain stability of the deployment, completely negating human errors such as forgetting any one step in deployment. The deployment made is done the same everytime through an automated process</li> <li>Another reason is to speed up development as developers will not need to go through the manual deployment on every release</li></ul></li> <li>Github Actions
<ul><li>Github actions is a very useful CI/CD tool when the code is already hosted on github</li> <li>Compared to alternatives, it is much simpler to set up as it is one click away for every github repo, create a workflow yml file and thats it</li> <li>There are many pre-defined actions such as actions/checkout that you can use to simplify your dev-ops. In this case you don't need to write your own code to checkout your repository</li></ul></li> <li>Angular deployment
<ul><li>Angular has a package that allows you to build directly into your github pages</li> <li>This simplifies the process further since you simply call this command through the github actions for an immediate deployment</li></ul></li></ul> <p>I learned CI/CD through inspecting the code base, trying out different workflows in my own repos and youtube tutorials</p> <ul><li>The code base gave me a guideline as to the proper way and usage of workflows, along with the proper syntax of creating a workflow</li> <li>Youtube gave me broader knowledge into creating my own workflows not specific to the CATcher project</li> <li>Trying out creating my own workflows and contributing to WATcher workflows solidified my understanding and gave me confidence in what I learned</li></ul> <h3 id="code-quality">Code Quality<a href="#code-quality" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p>Code quality is always important but is especially so when there are so many people working on the same project. Since large portions of WATcher was copied from CATcher, WATcher was made overtly large with a great number of redundant code. It was very poor code quality and the importance of code quality was made clear.</p> <ul><li>Code Cleanliness
<ul><li>Redundant code clutters the code base, making it especially hard to understand certain functionality since you have to sift through so much to find what you are looking for</li> <li>As a new developer, it created an unecessarily difficult experience getting a grasp of the code base</li> <li>Over reliance on comments also clutters the code base when code should be self-explanatory</li> <li>Over three levels of indentation should be avoided, at which point the code is made very hard to understand and inner indents should be refactored into separate functions</li></ul></li> <li>Code simplicity (KISS)
<ul><li>There are many ways to do the same thing and it is always best to Keep It Simple</li> <li>Always use the simplest way to come to the same outcome, even if they use unecessary variables</li> <li>Variables and functions should be aptly named so they are understood readily such as a <code class="hljs inline no-lang">filteredData</code> variable for storing data after it has been filtered</li> <li>Since code is read more than it is written, keeping it simple allows future developers, even yourself to understand the purpose and reason behind any piece of code</li></ul></li> <li>Documentation
<ul><li>Documentation is important to help others understand parts of the code that are not immediately apparent</li> <li>However, it is important to not rely too heavily on documentation and wherever possible, code you write should be self-explanatory</li> <li>Instead of writing a one-liner that does everything, split logically linked portions into separate parts, using different functions or storing outputs in appropriately named variables</li></ul></li> <li>Following coding style
<ul><li>Assuming you are not the originator of the project, you need to follow the coding style of the project as well</li> <li>Since there are always multiple ways of doing the same thing, it is often arguable which way is the best. When joining an already established project, it is critical to follow the coding style of your predecessors</li> <li>An example would be returning a complete object instead of a part of an object and appending to a newly created object in the parent function. Both accomplish the same thing and arguably are equally understandable</li></ul></li></ul> <p>I learned about code quality through analysing the responses of seniors to my own pull requests as well as other's pull requests, supplementing my knowledge by reading articles on code quality both generally and specific to web development</p> <ul><li>Inspection of pull requests gave me understanding of what is good quality code and what is considered bad along with the reasoning behind those decisions</li> <li>Articles online provided me with more general guidelines pertaining to code quality in large projects, helping fill in the gaps that I didnt encounter in PR reviews</li></ul> <h3 id="testing">Testing<a href="#testing" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p>Testing is another important part of any project as it reduces the occurrence of major errors and bugs throughout development. With little prior experience in testing, I sought to learn more about it and apply it in WATcher.</p> <ul><li>Jasmine
<ul><li>A testing framework for javascript</li> <li>Clean and intuitive syntax</li> <li>Suite of functionality developed over many years</li> <li>I learned Jasmine through looking through test cases in CATcher and WATcher, along with reading its official documentation
<ul><li><code class="hljs inline no-lang">describe(string, function)</code> houses related specs labeled by string and defined as function</li> <li><code class="hljs inline no-lang">it(string, function)</code> defines a spec labeled by string and defined as function</li> <li><code class="hljs inline no-lang">expect(any).toBeFalse</code> defines an expectation of <code class="hljs inline no-lang">any</code>. There are a large number of matchers for any possible comparison</li> <li><code class="hljs inline no-lang">beforeEach(function)</code> defines a function to be called before each of the specs in this describe block</li> <li><code class="hljs inline no-lang">createSpyObj(string, string[])</code> creates a spy object that acts as a stub for classes that are depended on by what is being tested. Spies can track calls to it and all arguments</li></ul></li></ul></li> <li>Test case design
<ul><li>Boundary Value Analysis and equivalence partitioning
<ul><li>Boundary value analysis is a technique where tests are designed to include representatives of boundary values in a range</li> <li>Equivalence partitioning is a technique where input data is partitioned into units of equivalent data for which tests can be written</li> <li>These techniques allow for a smaller number of tests to be written, for essentially the same amount of coverage
<ul><li>This is because inputs which would fail/pass for the same reason, such as being an input of an invalid type, are grouped as a single or only a few test cases.</li> <li>The alternative would be to create tests for each input type in this example, straining developer resources for not much benefit</li></ul></li></ul></li> <li>Testing for behaviour
<ul><li>A common mistake is to test for implementation rather than behaviour</li> <li>This would result in failed test cases when implementation changes even though the resulting behaviour, what the user would experience, remains the same</li> <li>Test cases should test for what the result is versus what the implementation is</li> <li>An example would be testing whether a variable changes in component A correctly vs testing what other components receive from component A after the change</li> <li>A developer might edit the implementation of component A so the variable no longer changes, however the accurate behaviour of emission to other components remains the same and the test cases should not fail</li></ul></li> <li>Testing coverage
<ul><li>Test coverage is how much of the code has actually been ran through during testing
<ul><li>Function/method coverage : based on functions executed e.g., testing executed 90 out of 100 functions</li> <li>Statement coverage : based on the number of lines of code executed e.g., testing executed 23k out of 25k LOC</li> <li>Decision/branch coverage : based on the decision points exercised e.g., an if statement evaluated to both true and false with separate test cases during testing is considered 'covered'</li> <li>Condition coverage : based on the boolean sub-expressions, each evaluated to both true and false with different test cases</li></ul></li> <li>A good future implementation would be to implement code coverage as a github action report when making pull requests to main</li> <li>At the very least, all public functions of a class should be uniquely tested in order to verify behaviour seen by other components
I learned about testing web applications through Nereus, reading Jasmine documentation, articles and youtube videos about testing and the <a href="https://nus-cs2113-ay2324s2.github.io/website/index.html">CS2113 website</a></li></ul></li></ul></li> <li>Nereus imparted knowledge of testing which helped me understand the core fundamentals, allowing me to more quickly pick up the technique as I learnt, especially the test case implementation</li> <li>The Jasmine documentation gave me confidence in creating my own test cases for unique behaviour such as changing routes in testing</li> <li>Youtube videos, articles and the CS2113 website helped me to understand and implement test case design techniques to create comprehensive and well designed test cases</li></ul></div> <nav id="page-nav" class="fixed-header-padding" data-v-e6005420><div class="nav-component slim-scroll" data-v-e6005420></div> <!----></nav></div> <footer><div class="text-center"><p>[<strong>This site was generated using <img src="https://markbind.org/favicon.ico" width="25"> <a href="https://markbind.org/">MarkBind 5.4.0</a></strong> on Fri, 26 Apr 2024, 16:02:33 UTC]<br> <span class="dimmed"><small><small>favicon.ico of this site was made by <a href="https://www.flaticon.com/authors/smashicons" title="Smashicons">Smashicons</a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com</a> is licensed by <a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons BY 3.0" target="_blank">CC 3.0 BY</a></small></small></span></p></div></footer></div>
</body><script src="/2024/markbind/js/bootstrap-utility.min.js"></script>
<script>
  MarkBind.setupWithSearch()
</script>
</html>
