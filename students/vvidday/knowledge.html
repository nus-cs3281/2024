<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="generator" content="MarkBind 5.4.0">
    <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="stylesheet" href="/2024/markbind/css/bootstrap.min.css"> <link rel="stylesheet" href="/2024/markbind/fontawesome/css/all.min.css"> <link rel="stylesheet" href="/2024/markbind/glyphicons/css/bootstrap-glyphicons.min.css"><link rel="stylesheet" href="/2024/markbind/css/codeblock-light.min.css"><link rel="stylesheet" href="/2024/markbind/css/markbind.min.css"><script src="/2024/markbind/js/polyfill.min.js"></script>
    <script src="/2024/markbind/js/vue.min.js"></script>
    <script src="/2024/markbind/js/markbind.min.js"></script>
    <script src="knowledge.page-vue-render.js"></script><link rel="stylesheet" href="/2024/plugins/markbind-plugin-anchors/markbind-plugin-anchors.css"><link rel="stylesheet" href="/2024/plugins/markbind-plugin-tree/markbind-plugin-tree.css">
    
  <link rel="stylesheet" href="/2024/stylesheets/main.css">
<link rel="icon" href="/2024/favicon.ico"></head>
<script>
  const baseUrl = '/2024'
</script>
<body >
<div id="app" data-server-rendered="true"><header fixed=""><div placement="top" data-v-7c0fd418><nav class="navbar navbar-expand-md d-print-none navbar-dark bg-primary" data-v-7c0fd418><div class="container-fluid" data-v-7c0fd418><div class="navbar-left" data-v-7c0fd418><a href="/2024/index.html" title="Home" class="navbar-brand" data-v-7c0fd418>CS3281&amp;2-2024/Students</a></div> <div class="navbar-default" data-v-7c0fd418><ul class="navbar-nav me-auto mt-2 mt-lg-0" data-v-7c0fd418> <li class="nav-link dropdown" data-v-ccda25c0><a role="button" data-bs-toggle="dropdown" class="dropdown-toggle nav-link" data-v-ccda25c0>CS3281</a> <ul class="dropdown-menu" data-v-ccda25c0> <li data-v-ccda25c0><a href="/2024/index.html" class="dropdown-item" data-v-ccda25c0>Students</a></li> <li data-v-ccda25c0><a href="/2024/students/knowledge.html" class="dropdown-item" data-v-ccda25c0>Knowledge</a></li> <li data-v-ccda25c0><a href="https://nus-cs3281.github.io/2024-dashboard/?search=&amp;sort=groupTitle&amp;sortWithin=title&amp;timeframe=commit&amp;mergegroup=&amp;groupSelect=groupByAuthors&amp;breakdown=false" class="dropdown-item" data-v-ccda25c0>Code Dashboard</a></li></ul></li> <li class="nav-link dropdown" data-v-ccda25c0><a role="button" data-bs-toggle="dropdown" class="dropdown-toggle nav-link" data-v-ccda25c0>CS3282</a> <ul class="dropdown-menu" data-v-ccda25c0> <li data-v-ccda25c0><a href="/2024/cs3282-index.html" class="dropdown-item" data-v-ccda25c0>Students</a></li> <li data-v-ccda25c0><a href="/2024/students/talksSchedule.html" class="dropdown-item" data-v-ccda25c0>Lightning Talks</a></li></ul></li> <li data-v-7c0fd418><a href="/2024/instructions.html" class="nav-link" data-v-7c0fd418>Instructions</a></li> <li data-v-7c0fd418><a href="https://nus-cs3281.github.io/website/" class="nav-link" data-v-7c0fd418>CS3281&amp;2 Website <span data-v-7c0fd418><span aria-hidden="true" class="glyphicon glyphicon-share-alt" data-v-7c0fd418></span></span></a></li></ul></div> <ul class="navbar-nav navbar-right" data-v-7c0fd418><li data-v-7c0fd418><a href="https://github.com/nus-cs3281/2024" class="nav-link" data-v-7c0fd418><span data-v-7c0fd418><span aria-hidden="true" class="fab fa-github" data-v-7c0fd418></span></span></a></li></ul></div></nav> <div class="lower-navbar-container" style="display:none;" data-v-7c0fd418><!----> <!----></div></div></header> <div id="flex-body"><div id="content-wrapper" class="fixed-header-padding"><h3 id="vue-and-amp-options-api">Vue &amp; Options API<a href="#vue-and-amp-options-api" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p>Although I was already familiar with Vue, I only ever used the newer composition API, and thus had to learn the Options API that is used in the frontend of RepoSense.</p> <p>I got familiar with the API as I worked through the implementation of <a href="https://github.com/reposense/RepoSense/pull/1866">this PR</a>, which involved a decent amount of refactoring across multiple Vue files. The main resource that I used was the <a href="https://vuejs.org/guide/introduction.html">official Vue docs</a>, as it provides a comprehensive yet easy to understand overview of the different concepts. Additionally, it has a toggle to switch between the Composition API and Options API for each page of the documentation, allowing people who are already familiar with one to easily pick up the other.</p> <p>Here are some of the main things that I learnt:</p> <h4 id="importance-of-computed-properties">Importance of computed properties<a href="#importance-of-computed-properties" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h4> <p>In RepoSense, there are many properties that we need to calculate/obtain when other properties are changed. For instance, in the zoom panel, we need to maintain a list of commits to be displayed. This list needs to be re-calculated based on other properties, such as the author that is currently selected, the filters applied to the commits (e.g. only show commits in <code class="hljs inline no-lang">.js</code> files), etc. In Vue, such properties should be implemented as a <strong>computed property</strong> under the <code class="hljs inline no-lang">computed</code> object in the export.</p> <p>The main advantage of computed properties are that they are <strong>cached</strong>, and are only re-computed when one of their reactive dependencies are changed. In the above example, this would be equivalent to our list of displayed commits only being re-computed when the currently selected author is changed, or a filter is added/removed. This <strong>significantly improves performance</strong>, as if we were to implement the computation of a list in a normal method, it will be re-computed on <em>every</em> re-render, even if the re-render was triggered by an unrelated reactive item - resulting in the unnecessary re-computation of the same value. In a frontend application like RepoSense's reports where there are many such properties, utilising Vue's computed properties provides a much needed performance boost.</p> <h4 id="avoiding-direct-manipulation-of-dom">Avoiding direct manipulation of DOM<a href="#avoiding-direct-manipulation-of-dom" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h4> <p>One of the main advantages of using a framework like Vue is that certain aspects relating to modifying the DOM are abstracted away from the user. Vue handles reactivity for the user, by updating the DOM when reactive state is mutated. Hence, problems can arise when users bypass this functionality of Vue and manually modify the DOM within Vue components. This is because Vue has no knowledge of these modifications, resulting in potential modifications clashing with Vue's mutation of the DOM.</p> <p><a href="https://github.com/reposense/RepoSense/pull/1866">This PR</a> involved deprecating the use of a method that manually modified the DOM in order to toggle the show/hide state of commits. This method of toggling commits involved a manual mutation of a CSS class, while there was a synchronous method that calculated and updated the number of shown/hidden commits based on this CSS class, which was stored in a reactive variable. However, since Vue's updates to the DOM are asynchronous, this resulted in the variable always being one action behind the 'true' state, which caused an incorrect display of the show/hide all commit messages text. This problem was fixed by working 'within' Vue - modifying a reactive variable on toggle change, and letting Vue handle the DOM mutation. Hence, we should always try to solve the problem within the framework, and try as best as possible to avoid direct mutations of the DOM.</p> <h4 id="deep-vs-shallow-copy-when-passing-data">Deep vs Shallow copy when passing data<a href="#deep-vs-shallow-copy-when-passing-data" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h4> <p>When passing data between components, care should always be taken with regard to how the data is passed, and the consequences of any mutations of that data. If mutations to data only make sense within the context of a particular component, then it is preferable to pass a deep copy of the data to prevent said mutations from changing behaviour outside of its scope.</p> <h3 id="cypress-testing">Cypress testing<a href="#cypress-testing" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p>RepoSense utilizes <a href="https://www.cypress.io/">Cypress</a> for E2E testing, where the tests run in an actual browser that accesses the entire web page by URL, as opposed to only a particular view/component. The <a href="https://docs.cypress.io/guides/overview/why-cypress">Cypress docs</a> is a great resource for learning how to write tests, and was the main resource that I used when learning.</p> <h4 id="test-isolation">Test Isolation<a href="#test-isolation" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h4> <p>One of the main things that confused me at first was why Cypress was configured to 'start from scratch' for each test case, i.e. it starts from the beginning of the RepoSense report/from a reload of the entire app for every single test case. After reading the corresponding page of the <a href="https://docs.cypress.io/guides/core-concepts/test-isolation">docs</a>, I learnt that this was important to ensure the consistency &amp; usefulness of each individual test case. By resetting the DOM state before each test, it ensures that each test functions independently, which in turn ensures that the running of any test does not impact the outcome of other tests. Otherwise, there might be a scenario where test case A passes, but causes a change that results in test case B failing. In this case, the results of the tests might be misleading, as the failure was a result of actions not confined within the test case itself.</p> <p>Along a similar line, testing of functionality should be isolated whenever possible. One of the test cases that I wrote was to test that the toggle state of a file persisted after sort. My original idea was to toggle the state of the first file, then change the sort order from 'descending' to 'ascending' and checking the toggle state of the last file. However, this implementation relies on the correctness of the sort functionality, and hence an error in the sorting function might result in this test case failing, which would be misleading. Therefore, in the <a href="https://github.com/reposense/RepoSense/commit/1dd4ab44a1981023169f65ead4b24588c6344052#diff-c6e7d02d4131f1788f7ec1dc99e38edcee54f91e0774bc821361cc55d307b769R121">actual implementation</a>, the file is tracked by file path and searched for after the sort, which isolates this test case from the correctness of the sort functionality.</p> <h3 id="typescript">TypeScript<a href="#typescript" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <h4 id="importance-of-enums">Importance of enums<a href="#importance-of-enums" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h4> <p>TypeScript <a href="https://www.typescriptlang.org/docs/handbook/enums.html">supports enums</a> similar to other languages like Java. Having enums is very convenient when you want to restrict a variable to a certain set of values, instead of an entire type. For instance, in RepoSense, there are many instances where variables only take specific values, such as a sort type only having valid values equal to &quot;groupByNone&quot;, &quot;groupByRepos&quot; and &quot;groupByAuthors&quot;.</p> <p>In this instance, typing the variable as a <code class="hljs inline no-lang">string</code> would technically be correct, and it would detect errors in the scenario where the variable is set to other types. However, it does not detect errors in the case where the variable is an invalid string, such as <code class="hljs inline no-lang">GroupByNone</code> or <code class="hljs inline no-lang">groupByNon</code>. This can easily occur due to a developer error, as the string is also manually referenced throughout the codebase (e.g. <code class="hljs inline no-lang">filterType = 'groupByNone'</code>, <code class="hljs inline no-lang">if (filterType === 'groupByNone'))</code>) etc. If a typo was made in one of these references, it would still compile properly without warnings, but the bug would exist in production. Using enums helps us twofold - first, we can replace all manual references with the enum instead (e.g. <code class="hljs inline no-lang">filterType = FilterGroupSelection.GroupByNone</code>, <code class="hljs inline no-lang">if (filterType === FilterGroupSelection.GroupByNone)</code>), which would prevent any individual typos (and a typo such as <code class="hljs inline no-lang">FilterGroupSelection.GroupByNon</code> will fail to compile as the type does not exist), and secondly, if we want to change the string itself, we just have to change it in the enum definition instead of everywhere in the codebase.</p> <h4 id="type-predicates">Type Predicates<a href="#type-predicates" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h4> <p>Often, we have objects of similar types that work closely together (for instance, both stored in the same array), and we might have to distinguish between them in certain circumstances. For instance, in RepoSense, when we initially read the commits from the report generated by the backend, we store these commits as a certain type, but in the frontend we process these raw commits to add certain attributes to form a different type that inherits from the former. Hence, in the codebase, it is important to distinguish between these two types.</p> <p>In order to narrow the type (e.g. if we have an object that can be either one of the two types but we want to be certain which one it is), we can use <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates">Type predicates</a>, which narrows down the object type <strong>based on the compatability of that object</strong>. For instance, in RepoSense, I used <a href="https://github.com/vvidday/RepoSense/blob/c9048f56a2a2c67b559c89b50b05b4db2bb5e066/frontend/src/types/types.ts#L30">this type predicate</a> to differentiate between the <code class="hljs inline no-lang">Commit</code> and <code class="hljs inline no-lang">DailyCommit</code> type. The <code class="hljs inline no-lang">Commit</code> type extends <code class="hljs inline no-lang">DailyCommit</code>, but has an optional field <code class="hljs inline no-lang">deletions</code>. The type predicate checks whether the field <code class="hljs inline no-lang">deletions</code> exists on the object, and uses that to determine the type of the provided object. This is used in code where we have a bunch of objects which are minimally <code class="hljs inline no-lang">Commit</code>s, but we are not sure if they are <code class="hljs inline no-lang">DailyCommit</code>s. The type predicate allows us to distinguish this, and therefore safely access the appropriate objects (that have the <code class="hljs inline no-lang">deletions</code> field) as <code class="hljs inline no-lang">DailyCommit</code>s.</p> <h4 id="type-inference-vs-explicit-types">Type inference vs Explicit types<a href="#type-inference-vs-explicit-types" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h4> <p>One difference between TypeScript and traditionally strongly typed languages is the <strong>type inference</strong> feature of the TypeScript compiler. In TypeScript, in certain cases such as function return types, the compiler can infer the type of the return object from the code itself without explicit declaration from the programmer. For instance, consider the following code:</p> <pre><code class="hljs typescript"><span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">double</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) </span>{
</span><span>  <span class="hljs-keyword">return</span> x*<span class="hljs-number">2</span>;
</span><span>}
</span></code></pre><p>TypeScript automatically infers the return type to be <code class="hljs inline no-lang">number</code> in this case. Of course, we can define the return type explicitly:</p> <pre><code class="hljs typescript"><span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">double</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>{
</span><span>  <span class="hljs-keyword">return</span> x*<span class="hljs-number">2</span>;
</span><span>}
</span></code></pre><p>Which in this case would be functionally equivalent, with a small difference being explicit declaration reduces overhead, as the compiler doesn't need to do the inference. However, aside from that, at first glance explicit declaration <em>seems</em> redundant, as the compiler can do inference. However, solely relying on inference can be prone to bugs, because the compiler assumes that your function definition is correct. Consider this example:</p> <pre><code class="hljs typescript"><span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">double</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) </span>{
</span><span>  <span class="hljs-keyword">return</span> (x*<span class="hljs-number">2</span>).toString();
</span><span>}
</span></code></pre><p>Although the above is an obvious bug (assuming we want double to return a number), the TypeScript compiler doesn't know what the user wants, and so happily infers the return type as string. Essentially, the compiler will never throw an error on inference, because it assumes the user's function implementation is correct (as it doesn't know the user's intention).
However, if we know that we want the <code class="hljs inline no-lang">double</code> function to return a number, and use an explicit return type declaration, the same code will result in an error:</p> <pre><code class="hljs typescript"><span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">double</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>{
</span><span>  <span class="hljs-keyword">return</span> (x*<span class="hljs-number">2</span>).toString();
</span><span>}
</span></code></pre><p>Hence, there <em>is</em> value in explicit type declarations, which is essentially telling the TypeScript compiler &quot;I expect the function to return this&quot;, which allows TypeScript to check whether our function does indeed return the expected type, which adds value and improves type safety.</p></div> <nav id="page-nav" class="fixed-header-padding" data-v-e6005420><div class="nav-component slim-scroll" data-v-e6005420></div> <!----></nav></div> <footer><div class="text-center"><p>[<strong>This site was generated using <img src="https://markbind.org/favicon.ico" width="25"> <a href="https://markbind.org/">MarkBind 5.4.0</a></strong> on Thu, 25 Apr 2024, 8:25:22 UTC]<br> <span class="dimmed"><small><small>favicon.ico of this site was made by <a href="https://www.flaticon.com/authors/smashicons" title="Smashicons">Smashicons</a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com</a> is licensed by <a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons BY 3.0" target="_blank">CC 3.0 BY</a></small></small></span></p></div></footer></div>
</body><script src="/2024/markbind/js/bootstrap-utility.min.js"></script>
<script>
  MarkBind.setupWithSearch()
</script>
</html>
